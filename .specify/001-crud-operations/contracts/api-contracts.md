# API Contracts: CRUD Operations

**Feature**: CRUD Operations for Posts  
**Branch**: `001-crud-operations`  
**Date**: 2026-02-27

## Overview

This document defines the contracts for all API endpoints used in CRUD operations. These contracts specify request/response formats, headers, status codes, and error handling for integration with the JSONPlaceholder API.

---

## Base Configuration

**Base URL**: `https://jsonplaceholder.typicode.com`  
**Content-Type**: `application/json; charset=UTF-8`  
**HTTP Client**: Native Fetch API

---

## Endpoints

### 1. Create Post

**Endpoint**: `POST /posts`

**Purpose**: Create a new post with title and body content.

**Request**:

```typescript
// Headers
Content-Type: application/json

// Body
{
  "title": string,    // Required, 1-255 chars
  "body": string,     // Required, 1-5000 chars
  "userId": number    // Required, defaults to 1
}
```

**Request Example**:

```json
{
  "title": "My First Post",
  "body": "This is the content of my post with some #hashtags",
  "userId": 1
}
```

**Success Response**: `201 Created`

```typescript
{
  "id": number,       // Generated by API
  "title": string,
  "body": string,
  "userId": number
}
```

**Success Response Example**:

```json
{
  "id": 101,
  "title": "My First Post",
  "body": "This is the content of my post with some #hashtags",
  "userId": 1
}
```

**Error Responses**:

- `400 Bad Request`: Invalid request body, missing required fields
- `500 Internal Server Error`: Server error

**Client-Side Transformation**:
After receiving API response, the client transforms it to match the Post interface:

```typescript
const transformedPost: Post = {
  ...apiResponse,
  engagement: { likes: 0, comments: 0, shares: 0 },
  isLiked: false,
  timestamp: new Date(),
  hashtags: extractHashtags(apiResponse.body),
  imageUrl: undefined,
  user: undefined,
};
```

**Service Function Signature**:

```typescript
async function createPost(request: CreatePostRequest): Promise<Post>;
```

---

### 2. Update Post

**Endpoint**: `PATCH /posts/:id`

**Purpose**: Update an existing post's title and/or body. PATCH is preferred over PUT for partial updates.

**Path Parameters**:

- `id` (number, required): ID of the post to update

**Request**:

```typescript
// Headers
Content-Type: application/json

// Body
{
  "title": string,    // Required, 1-255 chars
  "body": string      // Required, 1-5000 chars
}
```

**Request Example**:

```
PATCH /posts/1
```

```json
{
  "title": "Updated Post Title",
  "body": "Updated content with new #tags"
}
```

**Success Response**: `200 OK`

```typescript
{
  "id": number,
  "title": string,
  "body": string,
  "userId": number
}
```

**Success Response Example**:

```json
{
  "id": 1,
  "title": "Updated Post Title",
  "body": "Updated content with new #tags",
  "userId": 1
}
```

**Error Responses**:

- `400 Bad Request`: Invalid request body
- `404 Not Found`: Post with given ID does not exist
- `500 Internal Server Error`: Server error

**Client-Side Transformation**:
Merge API response with existing post data:

```typescript
const updatedPost: Post = {
  ...existingPost, // Preserve engagement, isLiked, user, imageUrl
  ...apiResponse,
  timestamp: new Date(),
  hashtags: extractHashtags(apiResponse.body),
};
```

**Service Function Signature**:

```typescript
async function updatePost(request: UpdatePostRequest): Promise<Post>;
```

**Alternative**: `PUT /posts/:id`

- Requires sending all post fields (userId, title, body)
- Less efficient than PATCH
- Use only if PATCH is unsupported

---

### 3. Delete Post

**Endpoint**: `DELETE /posts/:id`

**Purpose**: Delete an existing post.

**Path Parameters**:

- `id` (number, required): ID of the post to delete

**Request**:

```
DELETE /posts/1
```

No request body required.

**Success Response**: `200 OK`

```json
{}
```

JSONPlaceholder returns an empty object on successful deletion.

**Error Responses**:

- `404 Not Found`: Post with given ID does not exist
- `500 Internal Server Error`: Server error

**Service Function Signature**:

```typescript
async function deletePost(postId: number): Promise<void>;
```

**Note**: The function returns `void` since the API response is an empty object. Success is determined by HTTP status code.

---

### 4. Get Post by ID (For Detail View)

**Endpoint**: `GET /posts/:id`

**Purpose**: Retrieve detailed information for a single post.

**Path Parameters**:

- `id` (number, required): ID of the post to retrieve

**Request**:

```
GET /posts/1
```

**Success Response**: `200 OK`

```typescript
{
  "id": number,
  "title": string,
  "body": string,
  "userId": number
}
```

**Error Responses**:

- `404 Not Found`: Post with given ID does not exist
- `500 Internal Server Error`: Server error

**Client-Side Transformation**:
Same as Create Post transformation.

**Service Function Signature**:

```typescript
async function getPostById(postId: number): Promise<Post>;
```

**Note**: This endpoint is optional for detail view. Since we already have the post in state, we can display it directly without an additional API call.

---

## Error Handling

### Error Response Format

JSONPlaceholder may not return structured error responses. Implement client-side error handling:

```typescript
interface APIErrorResponse {
  message: string;
  code?: string;
  status?: number;
}

async function handleAPIError(response: Response): Promise<never> {
  const status = response.status;
  const statusText = response.statusText;

  let errorMessage: string;

  switch (status) {
    case 400:
      errorMessage = 'Invalid request. Please check your input.';
      break;
    case 404:
      errorMessage = 'Post not found. It may have been deleted.';
      break;
    case 500:
      errorMessage = 'Server error. Please try again later.';
      break;
    default:
      errorMessage = `Request failed: ${statusText}`;
  }

  throw new Error(errorMessage);
}
```

### Network Errors

Handle network failures (no internet, server unreachable):

```typescript
try {
  const response = await fetch(url, options);
  if (!response.ok) {
    await handleAPIError(response);
  }
  return await response.json();
} catch (error) {
  if (error instanceof TypeError) {
    // Network error (fetch failed)
    throw new Error('Network error. Please check your connection.');
  }
  throw error; // Re-throw API errors
}
```

### Retry Logic (Optional)

Implement exponential backoff for transient failures:

```typescript
async function fetchWithRetry(
  url: string,
  options: RequestInit,
  maxRetries = 3,
  backoff = 1000
): Promise<Response> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok || response.status < 500) {
        return response; // Success or client error (don't retry)
      }
      // Server error, retry
    } catch (error) {
      if (i === maxRetries - 1) throw error;
    }

    await new Promise(resolve => setTimeout(resolve, backoff * Math.pow(2, i)));
  }

  throw new Error('Max retries exceeded');
}
```

---

## Service Layer Implementation

### File: `src/services/api.service.ts`

Add the following functions to the existing service:

```typescript
import type {
  Post,
  CreatePostRequest,
  UpdatePostRequest,
} from '@/types/post.types';

const API_BASE_URL = 'https://jsonplaceholder.typicode.com';

/**
 * Create a new post
 */
export async function createPost(request: CreatePostRequest): Promise<Post> {
  const response = await fetch(`${API_BASE_URL}/posts`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data = await response.json();

  // Transform to Post interface
  return {
    ...data,
    engagement: { likes: 0, comments: 0, shares: 0 },
    isLiked: false,
    timestamp: new Date(),
    hashtags: extractHashtags(data.body),
    imageUrl: undefined,
    user: undefined,
  };
}

/**
 * Update an existing post
 */
export async function updatePost(request: UpdatePostRequest): Promise<Post> {
  const { id, ...updateData } = request;

  const response = await fetch(`${API_BASE_URL}/posts/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(updateData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data = await response.json();

  // Transform to Post interface (preserve existing engagement, etc.)
  return {
    ...data,
    engagement: { likes: 0, comments: 0, shares: 0 }, // Ideally preserve from state
    isLiked: false,
    timestamp: new Date(),
    hashtags: extractHashtags(data.body),
    imageUrl: undefined,
    user: undefined,
  };
}

/**
 * Delete a post
 */
export async function deletePost(postId: number): Promise<void> {
  const response = await fetch(`${API_BASE_URL}/posts/${postId}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  // JSONPlaceholder returns {} on success, no transformation needed
}
```

---

## Testing Contracts

### Unit Tests

Test each service function with mocked fetch:

```typescript
// api.service.test.ts
describe('createPost', () => {
  it('should create post and transform response', async () => {
    global.fetch = jest.fn().mockResolvedValue({
      ok: true,
      json: async () => ({ id: 101, title: 'Test', body: 'Body', userId: 1 }),
    });

    const result = await createPost({ title: 'Test', body: 'Body', userId: 1 });

    expect(result).toMatchObject({
      id: 101,
      title: 'Test',
      body: 'Body',
      engagement: { likes: 0, comments: 0, shares: 0 },
      isLiked: false,
    });
  });

  it('should handle HTTP errors', async () => {
    global.fetch = jest.fn().mockResolvedValue({
      ok: false,
      status: 400,
    });

    await expect(
      createPost({ title: 'Test', body: 'Body', userId: 1 })
    ).rejects.toThrow('HTTP error! status: 400');
  });
});
```

### Integration Tests

Test actual API calls (optional, requires network):

```typescript
describe('API Integration Tests', () => {
  it('should create, update, and delete post', async () => {
    const created = await createPost({
      title: 'Test',
      body: 'Content',
      userId: 1,
    });
    expect(created.id).toBeDefined();

    const updated = await updatePost({
      id: created.id,
      title: 'Updated',
      body: 'New',
    });
    expect(updated.title).toBe('Updated');

    await expect(deletePost(created.id)).resolves.not.toThrow();
  });
});
```

---

## JSONPlaceholder Limitations

**Important**: JSONPlaceholder is a fake REST API for testing and prototyping.

**Limitations**:

- ✅ Accepts all HTTP methods (GET, POST, PATCH, PUT, DELETE)
- ✅ Returns realistic response structures
- ❌ Does NOT persist data - changes are not saved
- ❌ Always returns success responses (rarely throws 404/500)
- ❌ Generated IDs are simulated (always returns 101 for new posts)

**Implications for Demo**:

- CRUD operations will appear to work but won't persist across page reloads
- Multiple creates will return same ID (101) - use client-side temp IDs
- Deleted posts will reappear on refresh
- Consider adding localStorage persistence for better demo experience

**Migration Path**:
When integrating with a real backend:

1. Update `API_BASE_URL` to production endpoint
2. Add authentication headers (Bearer tokens, API keys)
3. Update error handling for backend-specific error formats
4. Adjust transformation logic if backend response structure differs
5. Remove optimistic update workarounds if backend is fast enough

---

## Next Steps

With API contracts defined, proceed to:

1. Define component interfaces in `contracts/component-contracts.md`
2. Create developer quickstart guide in `quickstart.md`
